\chapter{Hulpklassen in Java}
Per functionaliteit zal kort de werking en functie van de bijgevoegde Java-klassen worden toegelicht. Hoewel niet op package gesorteerd, maar op functionaliteit (grotendeels komt de packageverdeling overeen met verdeling per functionaliteit) zullen wel alle Java-klassen aan de orde komen. Voor verdere en uitgebreidere informatie over de werking van de in dit hoofdstuk genoemde Java-klassen kan men terecht bij de javadoc welke op cd-rom bij dit verslag is bijgevoegd of bij de daadwerkelijke implementatie van de Java-klassen welke allen zijn te vinden in Appendix G.

\section{Indenting}
De Java-klasse BaseOffSideLexer (in de package\emph{edu.utwente.vb.example}) is een subklasse van de standaard ANTLR-klasse Lexer en bevat methoden om om te gaan met whitespace-karakters als newlines en tabs op zo'n wijze dat Python-achtige indenting wordt gerealiseerd.

\section{Symboltable}
Een checker valt of staat met een goede en handige implementatie van een symboltable. Omdat het ontwikkelen van een goed functionerende en foutloze symboltable een vakgebied apart is en het de scope van dit vak te buiten gaat om grondig onderzoek te doen naar de optimale symboltable is er voor gekozen een bestaand symboltable-concept te gebruiken welke zijn waarde al heeft bewezen. In Aho~\cite[p.85-90]{aho2007compilers} staat een concept van een symboltable welke bruikbaar is binnen talen met een platte of geneste blokstructuur. Gezien dit hiermee goed aansluit aansluit bij onze taal hebben is deze symboltable gebruikt. Omdat een kant-en-klaar implementatie van deze symboltable ontbreekt en omdat implementatie nuttig is voor het verkrijgen van inzicht in de werking van de symboltable is deze symboltable zelfstandig ge\"{i}mplementeerd. De complete package \emph{edu.utwente.vb.symbols} van de bijgevoegde Java-klassen omvat de klassen van deze Symboltable.

\section{Ingebouwde functies}
Zowel de checker als de codegenerator behoeven te weten welke functies standaard in de Example programmeertaal zijn ingebouwd. De checker moet immers kunnen controleren of een functie die in een programma wordt aangeroepen wel is gedefinieerd. De codegenerator moet weten welke instructies uitgevoerd moeten worden bij een aanroep van een van de ingebouwde functies. Bij de javaklassen in appendix G is in de sectie Symboltable de klasse Prelude te vinden. Net als de complete symboltable waar prelude nauw mee verwant is kan men Prelude terug vinden in de package \emph{edu.utwente.vb.symbols}. De klasse prelude definieerd voor de checker alle standaard ingebouwde functies van Example met bijbehorende parametertypen en typen van de teruggeefwaarde. Eenmalig schrijft Prelude alle voorgedefinieerde methoden die ze bevat in de symboltable. Om de daadwerkelijke check uit te voeren vindt communicatie plaats tussen de klasse Checker en de symboltable (welke het daadwerkelijke typen van variabele en alle gedefinieerde functies bijhoudt). Voor de codegenerator is de klasse Builtins (\emph{edu.utwente.vb.example.Builtins}) geschreven, welke een in Java gedefinieerde library van functies is voor de Example programmeertaal.

\section{Exceptionhandling}
Foutafhandeling is een essentieel onderdeel van een compiler. Informatieve en sturende foutmeldingen geven de gebruiker van de programmeertaal een beeld van het soort fout dat is gemaakt en waar deze fout is opgetreden. Om informatieve foutmeldingen in Example te ondersteunen is de klasse SymboltableException en zijn drie subklassen IncompatibleTypesException, IllegalVariableDefinitionException en IllegalFunctionDefinitionException ge\"{i}mplementeerd (te vinden in de package \emph{edu.utwente.vb.exceptions}). Deze zijn allen (al dan niet indirect) een subklasse van de standaard ANTLR exceptieklasse RecognitionException en vullen deze klasse in door de standaard errormessage vooraf te laten gaan door het regelnummer en de karakterpositie van de token waarop de fout is ontstaan. Het voorzien van gebruikers van de programmeertaal met de positie van de fouten faciliteert immers enorm in het oplossen van fouten, gezien de programmeur de plaats van de fout niet meer zelf hoeft te zoeken.
IncompatibleTypesException, IllegalVariableDefinitionException en IllegalFunctionDefinitionException bestaan als subklassen van SymbolTableException en hebben als doen om duidelijkere foutmeldingen te geven in specifieke situaties. IncompatibleTypesException wordt gegooid zodra er een toekenning uitgevoerd wordt waarbij het typen van de variabele/constante en de toe te kennen waarde niet overeen komen.
IllegalVariableDefinitionException wordt gegooid zodra een programmeur probeert een variabele te declareren op onjuiste wijze (bijvoorbeeld als type void). IllegalFunctionDefinitionException wordt gegooid zodra een programmeur probeert op onjuiste wijze een functie te declareren.

De members van de grammaticabronnen parser.g en checker.g zijn op zo'n wijze ontwikkeld dat alle fouten achter elkaar worden verzameld, zodat meerdere fouten genummerd onder elkaar kunnen worden weergegeven. Door in de members van de parser ook de methode displayRecognitionError() te overriden zijn de foutmeldingen die bij alle typen RecognitionException worden weergegeven op maat gemaakt voor de Example taal.

\section{De klasse Compiler}
De klasse compiler \emph{edu.utwente.vb.example.Compiler} is de aan te roepen klassen voor het gebruik van de Example compiler. Bij aanroep doorloopt Compiler de verschillende lagen van de Example compiler met de megegeven programmacode, van Lexer totaan de Codegenerator. De compiler klasse kan vanaf de commandline worden aangeroepen en kent daarbij enkele mogelijke commandlineparameters:
\begin{description}
    \item[--opt\_ast]                   Optie om de Abstract Syntax Tree behorend bij dit testprogramma terug te geven in codenotatie
    \item[--opt\_debug]                 Zet het gooien van Excepties aan, deze optie is nodig zodat de testsuite fouten kan herkennen
    \item[--opt\_debug\_checker]        Start een debug sessie voor de checker, welke vanaf ANTLR-works benaderbaar is
    \item[--opt\_debug\_codegen]        Start een debug sessie voor de codegenerator, welke vanaf ANTLR-works benaderbaar is
    \item[--opt\_debug\_parser]         Start een debug sessie voor de parser, welke vanaf ANTLR-works benaderbaar is
    \item[--opt\_debug\_preparation]    Start een debug sessie voor de codegeneratie voorbereidingsfase, welke vanaf ANTLR-works benaderbaar is
    \item[--opt\_dot]                   Optie om de Abstract Syntax Tree behorend bij dit testprogramma terug te geven in DOT-notatie
    \item[--opt\_file\_input]           Hier kan de inputfile voor de compiler mee worden aangegeven
    \item[--opt\_no\_checker]           Zorgt voor uitvoer van enkel de parserlaag
    \item[--opt\_no\_codegen]           Zorgt voor uitvoer tot en met de checkerlaag
    \item[--opt\_no\_interpreter]       Zorgt voor uitvoer tot en met de codegeneratielaag
\end{description}

\section{CheckerHelper}
Om de grammatica van de checker (checker.g) zo schoon mogelijk te houden en vervuiling met Java-code te minimaliseren is de klasse CheckerHelper (\emph{edu.utwente.vb.example.util.CheckerHelper} in het leven geroepen. De aangehouden richtlijn die is om overal waar het nodig was om meer dan twee regels Java-code in te voegen in checker.g, deze code te verplaatsen naar een functie in de hulpklasse CheckerHelper om vervolgens in de checker enkel de hulpfunctie van CheckerHelper aan te hoeven roepen. Slechts op enkele plaatsen is uit pragmatisch oogpunt een uitzondering gemaakt op deze richtlijn. CheckerHelper bevat onder andere functies voor het definieren van variabelen, het definieren van functies, het openen en sluiten van scopes en het uitvoeren van functies. Om de werking van de klasse CheckerHelper te schetsen zal kort de stappen worden geschetst welke CheckerHelper uitvoert bij aanroep van een functie.
Voor het uitvoeren van functies communiceert CheckerHelper met de symboltable (zie sectie "Symboltable") om te controleren of de aangeroepen functie met de meegegeven datatypen van parameters gedefinieerd is, is dit niet het geval dan is het ook de CheckerHelper die zorgt voor het gooien van een exceptie (SymbolTableException). Tevens wordt het nodetype in de boom gezet op het datatype dat deze functie teruggeeft, dit is handig om in de boom te hebben staan in de codegeneratiefase.

\section{Utils}
De klasse Utils (\emph{edu.utwente.vb.example.util.Utils}) bevat een aantal statische utility-functies die vanuit andere klassen kunnen worden aangeroepen. Utils bevat statische methoden om betandsnamen om te zetten naar CamelCaseNotatie, om quotes van strings af te strippen, om op te vragen of het datatype van een node bekend/onbekend is. Utils is zeker niet de kern van de aan Example gerelateerde Java-klasse, maar biedt ondersteuning en hulp aan andere Java-klassen.

\section{Speciale NodeTypen}
De package \emph{edu.utwente.vb.tree} bevat diverse zelfgemaakte nodetypen waarvan in de ANTLR files gebruikt wordt gemaakt. Deze nodetypen zijn alle subklassen van het standaard ANTLR nodetype CommonTree. TypedNode is het standaard nodetype waarvan Example gebruikmaakt en is een aanvulling op CommonTree doordat het de mogelijkheid biedt (Example-)datatypen toe te kennen aan nodes in de boom. Toekenning van types aan boomnodes biedt ondersteuning aan de checker, doordat het de checker. In het voorbeeld van een assignment doet de checker namelijk hetvolgende: 
\begin{itemize}
\item het linker kind van de assignnode wordt ge\"{e}valueerd
\item de variabele die het linker kind is vraagt zijn datatype op (staat in zijn eigen TypedNode) en gooit deze de gehele structuur tot de assign omhoog zodat ook het linker kind van de assignnode dit datatype opgeslagen in zijn TypedNode heeft
\item het rechterkind wordt ge\"{e}valueerd
\item het rechterkind gooit zijn nodetype omhoog
\item de CheckerHelper vraagt de checkerhelper of functie '=' gedefinieerd is met als parameters het type van de linker kindnode van assign en het type van de  rechter kindnode van assign
\item afhankelijk van of de typen van de kinderen valide zijn gooit CheckerHelper een exceptie of niet
\end{itemize}
Het opslaan van datatypen in de nodes biedt de checker de mogelijkheid op deze eenvoudige wijze te controleren of acties qua typen geldig zijn.\\
Het nodetype BindingOccurrenceNode wordt gebruikt voor declaraties van een constanten/variabelen. Het nodetype AppliedOccurrenceNode is het nodetype dat wordt gebruikt wanneer een aangemaakte variabele/constante wordt gebruikt. Bij het aanmaken van de AppliedOccurrenceNode wordt de BindingOccurrenceNode meegegeven waar deze variabele of constante wordt gedefinieerd. In fase van codegenereren wordt hier handig gebruik van gemaakt doordat bij een 'applied occurrence' van een variabele eenvoudig via aanroep van een getBindingNode()-methode de oorspronkelijke variabele weer opgehaald kan worden.\\

\section{ASMAdapter}
De ASMAdapter (\emph{edu.utwente.vb.example.asm.ASMAdapter} is de kern van de Example compiler als het gaat om creatie van JVM-bytecode. Waar CheckerHelper feitelijk de klasse is die als functie-library voor de checker fungeert is ASMAdapter dit voor de codegenerator. ASMAdapter implementeert voor elke controlestructuur een visit-methode waarin met behulp van de ASM~\cite{ASM} bytecode generation library JVM code wordt gecre\"{e}erd. In het hoofdstuk vertaalregels staat een overzicht welke bytecode door elke constructie wordt gecre\"{e}erd.
