\chapter{Hulpklassen in Java}
De implementatie van alle hieronder genoemde Java-klassen zijn bijgevoegd in Appendix G.

\section{Indenting}
De Java-klasse BaseOffSideLexer (in de package\emph{edu.utwente.vb.example.BaseOffSideLexer}) is een subklasse van de standaard ANTLR-klasse Lexer en bevat methoden om om te gaan met whitespace-karakters als newlines en tabs op zo'n wijze dat Python-achtige indenting wordt gerealiseerd.

\section{Symboltable}
Een checker valt of staat met een goede en handige implementatie van een symboltable. Omdat het ontwikkelen van een goed functionerende en foutloze symboltable een vakgebied apart is en het de scope van dit vak te buiten gaat om grondig onderzoek te doen naar de optimale symboltable is er voor gekozen een bestaand symboltable-concept te gebruiken welke zijn waarde al heeft bewezen. In Aho~\cite[p.85-90]{aho2007compilers} staat een concept van een symboltable welke bruikbaar is binnen talen met een platte of geneste blokstructuur. Gezien dit hiermee goed aansluit aansluit bij onze taal hebben is deze symboltable gebruikt. Omdat een kant-en-klaar implementatie van deze symboltable ontbreekt en omdat implementatie nuttig is voor het verkrijgen van inzicht in de werking van de symboltable is deze symboltable zelfstandig ge\"{i}mplementeerd. De complete package \emph{edu.utwente.vb.symbols} van de bijgevoegde Java-klassen omvat de klassen van deze Symboltable.

\section{Ingebouwde functies}
Zowel de checker als de codegenerator behoeven te weten welke functies standaard in de Example programmeertaal zijn ingebouwd. De checker moet immers kunnen controleren of een functie die in een programma wordt aangeroepen wel is gedefinieerd. De codegenerator moet weten welke instructies uitgevoerd moeten worden bij een aanroep van een van de ingebouwde functies. Bij de javaklassen in appendix G is in de sectie Symboltable de klasse Prelude te vinden. Net als de complete symboltable waar prelude nauw mee verwant is kan men Prelude terug vinden in de package \emph{edu.utwente.vb.symbols}. De klasse prelude definieerd voor de checker alle standaard ingebouwde functies van Example met bijbehorende parametertypen en typen van de teruggeefwaarde. Om de daadwerkelijke check uit te voeren vindt communicatie plaats tussen de klasse Prelude (welke de operaties/functies bijhoudt en de datatypen waarmee deze werken) en de symboltable (welke het daadwerkelijke type van variabele bijhoudt). Voor de codegenerator is de klasse Builtins (\emph{edu.utwente.vb.example}) geschreven, welke een in Java gedefinieerde library van functies is voor de Example programmeertaal.

\section{Exceptionhandling}
Foutafhandeling is een essentieel onderdeel van een compiler. Informatieve en sturende foutmeldingen geven de gebruiker van de programmeertaal een beeld van het soort fout dat is gemaakt en waar deze fout is opgetreden. Om informatieve foutmeldingen in Example te ondersteunen is de klasse SymboltableException en zijn drie subklassen IncompatibleTypesException, IllegalVariableDefinitionException en IllegalFunctionDefinitionException ge\"{i}mplementeerd (te vinden in de package \emph{edu.utwente.vb.exceptions}). Deze zijn allen (al dan niet indirect) een subklasse van de standaard ANTLR exceptieklasse RecognitionException en vullen deze klasse in door de standaard errormessage vooraf te laten gaan door het regelnummer en de karakterpositie van de token waarop de fout is ontstaan. Het voorzien van gebruikers van de programmeertaal met de positie van de fouten faciliteert immers enorm in het oplossen van fouten, gezien de programmeur de plaats van de fout niet meer zelf hoeft te zoeken.
IncompatibleTypesException, IllegalVariableDefinitionException en IllegalFunctionDefinitionException bestaan als subklassen van SymbolTableException en hebben als doen om duidelijkere foutmeldingen te geven in specifieke situaties. IncompatibleTypesException wordt gegooid zodra er een toekenning uitgevoerd wordt waarbij het typen van de variabele/constante en de toe te kennen waarde niet overeen komen.
IllegalVariableDefinitionException wordt gegooid zodra een programmeur probeert een variabele te declareren op onjuiste wijze (bijvoorbeeld als type void). IllegalFunctionDefinitionException wordt gegooid zodra een programmeur probeert op onjuiste wijze een functie te declareren.

De members van de grammaticabronnen parser.g en checker.g zijn op zo'n wijze ontwikkeld dat alle fouten achter elkaar worden verzameld, zodat meerdere fouten genummerd onder elkaar kunnen worden weergegeven. Door in de members van de parser ook de methode displayRecognitionError() te overriden zijn de foutmeldingen die bij alle typen RecognitionException worden weergegeven op maat gemaakt voor de Example taal.

\section{De klasse Compiler}
De klasse compiler \emph{edu.utwente.vb.example} is de aan te roepen klassen voor het gebruik van de Example compiler. Bij aanroep doorloopt Compiler de verschillende lagen van de Example compiler met de megegeven programmacode, van Lexer totaan de Codegenerator. De compiler klasse kan vanaf de commandline worden aangeroepen en kent daarbij enkele mogelijke commandlineparameters:
\begin{description}
    \item[--opt\_ast]                   Optie om de Abstract Syntax Tree behorend bij dit testprogramma terug te geven in codenotatie
    \item[--opt\_debug]                 Zet het gooien van Excepties aan, deze optie is nodig zodat de testsuite fouten kan herkennen
    \item[--opt\_debug\_checker]        Start een debug sessie voor de checker, welke vanaf ANTLR-works benaderbaar is
    \item[--opt\_debug\_codegen]        Start een debug sessie voor de codegenerator, welke vanaf ANTLR-works benaderbaar is
    \item[--opt\_debug\_parser]         Start een debug sessie voor de parser, welke vanaf ANTLR-works benaderbaar is
    \item[--opt\_debug\_preparation]    Start een debug sessie voor de codegeneratie voorbereidingsfase, welke vanaf ANTLR-works benaderbaar is
    \item[--opt\_dot]                   Optie om de Abstract Syntax Tree behorend bij dit testprogramma terug te geven in DOT-notatie
    \item[--opt\_file\_input]           Hier kan de inputfile voor de compiler mee worden aangegeven
    \item[--opt\_no\_checker]           Zorgt voor uitvoer van enkel de parserlaag
    \item[--opt\_no\_codegen]           Zorgt voor uitvoer tot en met de checkerlaag
    \item[--opt\_no\_interpreter]       Zorgt voor uitvoer tot en met de codegeneratielaag
\end{description}
